@inproceedings{matsakis2014rust,
  title={The rust language},
  author={Matsakis, Nicholas D and Klock II, Felix S},
  booktitle={ACM SIGAda Ada Letters},
  volume={34},
  number={3},
  pages={103--104},
  year={2014},
  organization={ACM}
}

@article{verus,
author = {Lattuada, Andrea and Hance, Travis and Cho, Chanhee and Brun, Matthias and Subasinghe, Isitha and Zhou, Yi and Howell, Jon and Parno, Bryan and Hawblitzel, Chris},
title = {Verus: Verifying Rust Programs using Linear Ghost Types},
year = {2023},
issue_date = {April 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {OOPSLA1},
url = {https://doi.org/10.1145/3586037},
doi = {10.1145/3586037},
abstract = {The Rust programming language provides a powerful type system that checks linearity and borrowing, allowing code to safely manipulate memory without garbage collection and making Rust ideal for developing low-level, high-assurance systems. For such systems, formal verification can be useful to prove functional correctness properties beyond type safety. This paper presents Verus, an SMT-based tool for formally verifying Rust programs.  
With Verus, programmers express proofs and specifications using the Rust language, allowing proofs to take advantage of Rust's linear types and borrow checking. We show how this allows proofs to manipulate linearly typed permissions that let Rust code safely manipulate memory, pointers, and concurrent resources. Verus organizes proofs and specifications using a novel mode system that distinguishes specifications, which are not checked for linearity and borrowing, from executable code and proofs, which are checked for linearity and borrowing.  
We formalize Verus' linearity, borrowing, and modes in a small lambda calculus, for which we prove type safety and termination of specifications and proofs. We demonstrate Verus on a series of examples, including pointer-manipulating code (an xor-based doubly linked list), code with interior mutability, and concurrent code.},
journal = {Proc. ACM Program. Lang.},
month = apr,
articleno = {85},
numpages = {30},
keywords = {Rust, linear types, systems verification}
}


@INPROCEEDINGS{kani,
  author={VanHattum, Alexa and Schwartz-Narbonne, Daniel and Chong, Nathan and Sampson, Adrian},
  booktitle={2022 IEEE/ACM 44th International Conference on Software Engineering: Software Engineering in Practice (ICSE-SEIP)}, 
  title={Verifying Dynamic Trait Objects in Rust}, 
  year={2022},
  volume={},
  number={},
  pages={321-330},
  keywords={Codes;Semantics;Ecosystems;Libraries;Safety;Reliability;Virtualization;Rust;verification;model checking;dynamic dispatch},
  doi={10.1145/3510457.3513031}}

@misc{kroening2023cbmccboundedmodel,
      title={CBMC: The C Bounded Model Checker}, 
      author={Daniel Kroening and Peter Schrammel and Michael Tautschnig},
      year={2023},
      eprint={2302.02384},
      archivePrefix={arXiv},
      primaryClass={cs.SE},
      url={https://arxiv.org/abs/2302.02384}, 
}

@misc{foroushaani2022modularformalverificationrust,
      title={Modular Formal Verification of Rust Programs with Unsafe Blocks}, 
      author={Nima Rahimi Foroushaani and Bart Jacobs},
      year={2022},
      eprint={2212.12976},
      archivePrefix={arXiv},
      primaryClass={cs.LO},
      url={https://arxiv.org/abs/2212.12976}, 
}

@article{RefinedRust,
author = {G\"{a}her, Lennard and Sammler, Michael and Jung, Ralf and Krebbers, Robbert and Dreyer, Derek},
title = {RefinedRust: A Type System for High-Assurance Verification of Rust Programs},
year = {2024},
issue_date = {June 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {PLDI},
url = {https://doi.org/10.1145/3656422},
doi = {10.1145/3656422},
abstract = {Rust is a modern systems programming language whose ownership-based type system statically guarantees memory safety, making it particularly well-suited to the domain of safety-critical systems. In recent years, a wellspring of automated deductive verification tools have emerged for establishing functional correctness of Rust code. However, none of the previous tools produce foundational proofs (machine-checkable in a general-purpose proof assistant), and all of them are restricted to the safe fragment of Rust. This is a problem because the vast majority of Rust programs make use of unsafe code at critical points, such as in the implementation of widely-used APIs. We propose RefinedRust, a refinement type system—proven sound in the Coq proof assistant—with the goal of establishing foundational semi-automated functional correctness verification of both safe and unsafe Rust code. We have developed a prototype verification tool implementing RefinedRust. Our tool translates Rust code (with user annotations) into a model of Rust embedded in Coq, and then checks its adherence to the RefinedRust type system using separation logic automation in Coq. All proofs generated by RefinedRust are checked by the Coq proof assistant, so the automation and type system do not have to be trusted. We evaluate the effectiveness of RefinedRust by verifying a variant of Rust’s Vec implementation that involves intricate reasoning about unsafe pointer-manipulating code.},
journal = {Proc. ACM Program. Lang.},
month = jun,
articleno = {192},
numpages = {25},
keywords = {Iris, Rust, program verification, separation logic}
}


@misc{Qwaz_rust-cve,
  author       = {Qwaz},
  title        = {rust-cve: CVEs for the Rust standard library},
  year         = {2025},
  publisher    = {GitHub},
  howpublished = {\url{https://github.com/Qwaz/rust-cve}},
  note         = {GitHub repository, accessed on March 3, 2025}
}

@software{Iris_contributors_Iris,
author = {{Iris contributors}},
doi = {10.5281/zenodo.595182},
license = {BSD-3-Clause},
title = {{Iris}},
url = {https://github.com/SciTools/iris}
}

@misc{verus_publications,
  title        = {Verus --- Publications and Projects},
  howpublished = {\url{https://verus-lang.github.io/verus/publications-and-projects/}},
  note         = {Accessed: 2025-03-04},
  year         = {2025}
}

@article{Prophecy,
author = {Jung, Ralf and Lepigre, Rodolphe and Parthasarathy, Gaurav and Rapoport, Marianna and Timany, Amin and Dreyer, Derek and Jacobs, Bart},
title = {The future is ours: prophecy variables in separation logic},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371113},
doi = {10.1145/3371113},
abstract = {Early in the development of Hoare logic, Owicki and Gries introduced auxiliary variables as a way of encoding information about the history of a program’s execution that is useful for verifying its correctness. Over a decade later, Abadi and Lamport observed that it is sometimes also necessary to know in advance what a program will do in the future. To address this need, they proposed prophecy variables, originally as a proof technique for refinement mappings between state machines. However, despite the fact that prophecy variables are a clearly useful reasoning mechanism, there is (surprisingly) almost no work that attempts to integrate them into Hoare logic. In this paper, we present the first account of prophecy variables in a Hoare-style program logic that is flexible enough to verify logical atomicity (a relative of linearizability) for classic examples from the concurrency literature like RDCSS and the Herlihy-Wing queue. Our account is formalized in the Iris framework for separation logic in Coq. It makes essential use of ownership to encode the exclusive right to resolve a prophecy, which in turn enables us to enforce soundness of prophecies with a very simple set of proof rules.},
journal = {Proc. ACM Program. Lang.},
month = dec,
articleno = {45},
numpages = {32},
keywords = {Iris, Prophecy variables, linearizability, logical atomicity, separation logic}
}

@inproceedings{Prusti,
author = {Astrauskas, Vytautas and B\'{\i}l\'{y}, Aurel and Fiala, Jon\'{a}\v{s} and Grannan, Zachary and Matheja, Christoph and M\"{u}ller, Peter and Poli, Federico and Summers, Alexander J.},
title = {The Prusti Project: Formal Verification for Rust},
year = {2022},
isbn = {978-3-031-06772-3},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-031-06773-0_5},
doi = {10.1007/978-3-031-06773-0_5},
abstract = {Rust is a modern systems programming language designed to offer both performance and static safety. A key distinguishing feature is a strong type system, which enforces by default that memory is either shared or mutable, but never both. This guarantee is used to prevent common pitfalls such as memory errors and data races. It can also be used to greatly simplify formal verification, as we demonstrated by developing the Prusti verifier, which can verify rich correctness properties of Rust programs with a very modest annotation overhead. In this paper, we provide an overview of the Prusti project. We outline its main design goals, illustrate examples of its use, and discuss important outcomes from the perspectives of a user, a verification expert, and a tool developer.},
booktitle = {NASA Formal Methods: 14th International Symposium, NFM 2022, Pasadena, CA, USA, May 24–27, 2022, Proceedings},
pages = {88–108},
numpages = {21},
keywords = {Separation logic, Deductive verification, Rust},
location = {Pasadena, CA, USA}
}

@inproceedings{Creusot,
author = {Denis, Xavier and Jourdan, Jacques-Henri and March\'{e}, Claude},
title = {Creusot: A Foundry for the Deductive Verification of Rust Programs},
year = {2022},
isbn = {978-3-031-17243-4},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-031-17244-1_6},
doi = {10.1007/978-3-031-17244-1_6},
abstract = {Rust is a fairly recent programming language for system programming, bringing static guarantees of memory safety through a strict ownership policy. The strong guarantees brought by this feature opens promising progress for deductive verification, which aims at proving the conformity of Rust code with respect to a specification of its intended behavior. We present the foundations of Creusot, a tool for the formal specification and deductive verification of Rust code. A first originality comes from Creusot’s specification language, which features a notion of prophecy to reason about memory mutation, working in harmony with Rust’s ownership system. A second originality is how Creusot builds upon Rust trait system to provide several advanced abstraction features.},
booktitle = {Formal Methods  and Software Engineering: 23rd International Conference on Formal Engineering Methods, ICFEM 2022, Madrid, Spain, October 24–27, 2022, Proceedings},
pages = {90–105},
numpages = {16},
keywords = {Rust programming language, Deductive program verification, Aliasing and ownership, Prophecies, Traits},
location = {Madrid, Spain}
}

@phdthesis{VerifyingConcurrentSystemsCode,
  title        = {Verifying Concurrent Systems Code},
  author       = {Travis Hance},
  year         = 2024,
  month        = {August},
  address      = {Pittsburgh, PA},
  note         = {Available at \url{https://www.andrew.cmu.edu/user/bparno/papers/hance_thesis.pdf}},
  school       = {Carnegie Mellon University},
  type         = {PhD thesis}
}

@article{linearDafny,
author = {Li, Jialin and Lattuada, Andrea and Zhou, Yi and Cameron, Jonathan and Howell, Jon and Parno, Bryan and Hawblitzel, Chris},
title = {Linear types for large-scale systems verification},
year = {2022},
issue_date = {April 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {OOPSLA1},
url = {https://doi.org/10.1145/3527313},
doi = {10.1145/3527313},
abstract = {Reasoning about memory aliasing and mutation in software verification is a hard problem. This is especially true for systems using SMT-based automated theorem provers. Memory reasoning in SMT verification typically requires a nontrivial amount of manual effort to specify heap invariants, as well as extensive alias reasoning from the SMT solver. In this paper, we present a hybrid approach that combines linear types with SMT-based verification for memory reasoning. We integrate linear types into Dafny, a verification language with an SMT backend, and show that the two approaches complement each other. By separating memory reasoning from verification conditions, linear types reduce the SMT solving time. At the same time, the expressiveness of SMT queries extends the flexibility of the linear type system. In particular, it allows our linear type system to easily and correctly mix linear and nonlinear data in novel ways, encapsulating linear data inside nonlinear data and vice-versa. We formalize the core of our extensions, prove soundness, and provide algorithms for linear type checking. We evaluate our approach by converting the implementation of a verified storage system (about 24K lines of code and proof) written in Dafny, to use our extended Dafny. The resulting system uses linear types for 91\% of the code and SMT-based heap reasoning for the remaining 9\%. We show that the converted system has 28\% fewer lines of proofs and 30\% shorter verification time overall. We discuss the development overhead in the original system due to SMT-based heap reasoning and highlight the improved developer experience when using linear types.},
journal = {Proc. ACM Program. Lang.},
month = apr,
articleno = {69},
numpages = {28},
keywords = {systems verification, linear types}
}

@inproceedings{Rudra,
author = {Bae, Yechan and Kim, Youngsuk and Askar, Ammar and Lim, Jungwon and Kim, Taesoo},
title = {Rudra: Finding Memory Safety Bugs in Rust at the Ecosystem Scale},
year = {2021},
isbn = {9781450387095},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3477132.3483570},
doi = {10.1145/3477132.3483570},
abstract = {Rust is a promising system programming language that guarantees memory safety at compile time. To support diverse requirements for system software such as accessing low-level hardware, Rust allows programmers to perform operations that are not protected by the Rust compiler with the unsafe keyword. However, Rust's safety guarantee relies on the soundness of all unsafe code in the program as well as the standard and external libraries, making it hard to reason about their correctness. In other words, a single bug in any unsafe code breaks the whole program's safety guarantee.In this paper, we introduce RUDRA, a program that analyzes and reports potential memory safety bugs in unsafe Rust. Since a bug in unsafe code threatens the foundation of Rust's safety guarantee, our primary focus is to scale our analysis to all the packages hosted in the Rust package registry. RUDRA can scan the entire registry (43k packages) in 6.5 hours and identified 264 previously unknown memory safety bugs---leading to 76 CVEs and 112 RustSec advisories being filed, which represent 51.6\% of memory safety bugs reported to RustSec since 2016. The new bugs RUDRA found are non-trivial, subtle, and often made by Rust experts: two in the Rust standard library, one in the official futures library, and one in the Rust compiler. RUDRA is open-source, and part of its algorithm is integrated into the official Rust linter.},
booktitle = {Proceedings of the ACM SIGOPS 28th Symposium on Operating Systems Principles},
pages = {84–99},
numpages = {16},
keywords = {Rust, Program analysis, Memory-safety},
location = {Virtual Event, Germany},
series = {SOSP '21}
}


@MISC{CVE-2020-36317,
  title = {{CVE}-2020-36317.},
  howpublished = "Available from NVD, {CVE-ID} {CVE}-2020-36317.",
  month=dec # "~3",
  year = {2013},
  url={https://nvd.nist.gov/vuln/detail/cve-2020-36317},
  urldate={08 April 2025}
}

@inproceedings {Theusus,
author = {Kevin Boos and Namitha Liyanage and Ramla Ijaz and Lin Zhong},
title = {Theseus: an Experiment in Operating System Structure and State Management},
booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation (OSDI 20)},
year = {2020},
isbn = {978-1-939133-19-9},
pages = {1--19},
url = {https://www.usenix.org/conference/osdi20/presentation/boos},
publisher = {USENIX Association},
month = nov
}

@inproceedings {Redleaf,
author = {Vikram Narayanan and Tianjiao Huang and David Detweiler and Dan Appel and Zhaofeng Li and Gerd Zellweger and Anton Burtsev},
title = {{RedLeaf}: Isolation and Communication in a Safe Operating System},
booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation (OSDI 20)},
year = {2020},
isbn = {978-1-939133-19-9},
pages = {21--39},
url = {https://www.usenix.org/conference/osdi20/presentation/narayanan-vikram},
publisher = {USENIX Association},
month = nov
}

@inproceedings{TockOS,
author = {Levy, Amit and Campbell, Bradford and Ghena, Branden and Giffin, Daniel B. and Pannuto, Pat and Dutta, Prabal and Levis, Philip},
title = {Multiprogramming a 64kB Computer Safely and Efficiently},
year = {2017},
isbn = {9781450350853},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3132747.3132786},
doi = {10.1145/3132747.3132786},
abstract = {Low-power microcontrollers lack some of the hardware features and memory resources that enable multiprogrammable systems. Accordingly, microcontroller-based operating systems have not provided important features like fault isolation, dynamic memory allocation, and flexible concurrency. However, an emerging class of embedded applications are software platforms, rather than single purpose devices, and need these multiprogramming features. Tock, a new operating system for low-power platforms, takes advantage of limited hardware-protection mechanisms as well as the type-safety features of the Rust programming language to provide a multiprogramming environment for microcontrollers. Tock isolates software faults, provides memory protection, and efficiently manages memory for dynamic application workloads written in any language. It achieves this while retaining the dependability requirements of long-running applications.},
booktitle = {Proceedings of the 26th Symposium on Operating Systems Principles},
pages = {234–251},
numpages = {18},
location = {Shanghai, China},
series = {SOSP '17}
}

@misc{rax,
      title={Safe and usable kernel extensions with Rax}, 
      author={Jinghao Jia and Ruowen Qin and Milo Craun and Egor Lukiyanov and Ayush Bansal and Michael V. Le and Hubertus Franke and Hani Jamjoom and Tianyin Xu and Dan Williams},
      year={2025},
      eprint={2502.18832},
      archivePrefix={arXiv},
      primaryClass={cs.OS},
      url={https://arxiv.org/abs/2502.18832}, 
}

@inproceedings{sel4,
author = {Klein, Gerwin and Elphinstone, Kevin and Heiser, Gernot and Andronick, June and Cock, David and Derrin, Philip and Elkaduwe, Dhammika and Engelhardt, Kai and Kolanski, Rafal and Norrish, Michael and Sewell, Thomas and Tuch, Harvey and Winwood, Simon},
title = {seL4: formal verification of an OS kernel},
year = {2009},
isbn = {9781605587523},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1629575.1629596},
doi = {10.1145/1629575.1629596},
abstract = {Complete formal verification is the only known way to guarantee that a system is free of programming errors.We present our experience in performing the formal, machine-checked verification of the seL4 microkernel from an abstract specification down to its C implementation. We assume correctness of compiler, assembly code, and hardware, and we used a unique design approach that fuses formal and operating systems techniques. To our knowledge, this is the first formal proof of functional correctness of a complete, general-purpose operating-system kernel. Functional correctness means here that the implementation always strictly follows our high-level abstract specification of kernel behaviour. This encompasses traditional design and implementation safety properties such as the kernel will never crash, and it will never perform an unsafe operation. It also proves much more: we can predict precisely how the kernel will behave in every possible situation.seL4, a third-generation microkernel of L4 provenance, comprises 8,700 lines of C code and 600 lines of assembler. Its performance is comparable to other high-performance L4 kernels.},
booktitle = {Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles},
pages = {207–220},
numpages = {14},
keywords = {isabelle/hol, l4, microkernel, sel4},
location = {Big Sky, Montana, USA},
series = {SOSP '09}
}

@misc{Rust_for_Linux, url={https://rust-for-linux.com/}, journal={Rust for Linux}} 

@misc{chen2025automatedproofgenerationrust,
      title={Automated Proof Generation for Rust Code via Self-Evolution}, 
      author={Tianyu Chen and Shuai Lu and Shan Lu and Yeyun Gong and Chenyuan Yang and Xuheng Li and Md Rakib Hossain Misu and Hao Yu and Nan Duan and Peng Cheng and Fan Yang and Shuvendu K Lahiri and Tao Xie and Lidong Zhou},
      year={2025},
      eprint={2410.15756},
      archivePrefix={arXiv},
      primaryClass={cs.SE},
      url={https://arxiv.org/abs/2410.15756}, 
}

@misc{shefer2025llmsenableverificationmainstream,
      title={Can LLMs Enable Verification in Mainstream Programming?}, 
      author={Aleksandr Shefer and Igor Engel and Stanislav Alekseev and Daniil Berezun and Ekaterina Verbitskaia and Anton Podkopaev},
      year={2025},
      eprint={2503.14183},
      archivePrefix={arXiv},
      primaryClass={cs.SE},
      url={https://arxiv.org/abs/2503.14183}, 
}


@INPROCEEDINGS{RFL_security,
  author={Li, Zhaofeng and Narayanan, Vikram and Chen, Xiangdong and Zhang, Jerry and Burtsev, Anton},
  booktitle={2024 Annual Computer Security Applications Conference (ACSAC)}, 
  title={Rust for Linux: Understanding the Security Impact of Rust in the Linux Kernel}, 
  year={2024},
  volume={},
  number={},
  pages={548-562},
  keywords={Computer languages;Codes;Linux;Memory management;Semantics;Programming;Safety;Security;Device drivers;Kernel;linux;device driver;rust},
  doi={10.1109/ACSAC63791.2024.00054}}

@inproceedings{sessiontype,
author = {Jespersen, Thomas Bracht Laumann and Munksgaard, Philip and Larsen, Ken Friis},
title = {Session types for Rust},
year = {2015},
isbn = {9781450338103},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2808098.2808100},
doi = {10.1145/2808098.2808100},
abstract = {We present a library for specifying session types implemented in Rust, and discuss practical use cases through examples and demonstrate how session types may be used in a large-scale application. Specifically we adapt parts of the ad-hoc communication patterns in the Servo browser engine to use session typed channels. Session types provide a protocol abstraction, expanding on traditional typed communication channels, to ensure that communication takes place according to a specified protocol. Thus, the library allows us to provide compile-time guarantees of adherence to a specific protocol without incurring significant run-time penalties.},
booktitle = {Proceedings of the 11th ACM SIGPLAN Workshop on Generic Programming},
pages = {13–22},
numpages = {10},
keywords = {generic types, concurrency, Session types, Rust},
location = {Vancouver, BC, Canada},
series = {WGP 2015}
}
